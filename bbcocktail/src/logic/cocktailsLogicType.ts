// Generated by kea-typegen on Sat, 19 Apr 2025 20:42:15 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { Cocktail } from '../types/cocktailTypes'
import type { Ingredient, IngredientSearchItem } from '../types/ingredientTypes'

export interface cocktailsLogicType extends Logic {
  actionCreators: {
    fetchCocktails: () => {
      type: 'fetch cocktails (src.logic.cocktailsLogic)'
      payload: {
        value: true
      }
    }
    fetchIngredients: () => {
      type: 'fetch ingredients (src.logic.cocktailsLogic)'
      payload: {
        value: true
      }
    }
    setSearchTerm: (term: string) => {
      type: 'set search term (src.logic.cocktailsLogic)'
      payload: {
        term: string
      }
    }
    addSelectedIngredient: (ingredient: string) => {
      type: 'add selected ingredient (src.logic.cocktailsLogic)'
      payload: {
        ingredient: string
      }
    }
    removeSelectedIngredient: (ingredient: string) => {
      type: 'remove selected ingredient (src.logic.cocktailsLogic)'
      payload: {
        ingredient: string
      }
    }
    setSearchMode: (mode: 'complete' | 'missing') => {
      type: 'set search mode (src.logic.cocktailsLogic)'
      payload: {
        mode: 'complete' | 'missing'
      }
    }
    loadCocktails: () => {
      type: 'load cocktails (src.logic.cocktailsLogic)'
      payload: any
    }
    loadCocktailsSuccess: (
      cocktails: Cocktail[],
      payload?: any
    ) => {
      type: 'load cocktails success (src.logic.cocktailsLogic)'
      payload: {
        cocktails: Cocktail[]
        payload?: any
      }
    }
    loadCocktailsFailure: (
      error: string,
      errorObject?: any
    ) => {
      type: 'load cocktails failure (src.logic.cocktailsLogic)'
      payload: {
        error: string
        errorObject?: any
      }
    }
    loadIngredients: () => {
      type: 'load ingredients (src.logic.cocktailsLogic)'
      payload: any
    }
    loadIngredientsSuccess: (
      ingredients: Ingredient[],
      payload?: any
    ) => {
      type: 'load ingredients success (src.logic.cocktailsLogic)'
      payload: {
        ingredients: Ingredient[]
        payload?: any
      }
    }
    loadIngredientsFailure: (
      error: string,
      errorObject?: any
    ) => {
      type: 'load ingredients failure (src.logic.cocktailsLogic)'
      payload: {
        error: string
        errorObject?: any
      }
    }
  }
  actionKeys: {
    'fetch cocktails (src.logic.cocktailsLogic)': 'fetchCocktails'
    'fetch ingredients (src.logic.cocktailsLogic)': 'fetchIngredients'
    'set search term (src.logic.cocktailsLogic)': 'setSearchTerm'
    'add selected ingredient (src.logic.cocktailsLogic)': 'addSelectedIngredient'
    'remove selected ingredient (src.logic.cocktailsLogic)': 'removeSelectedIngredient'
    'set search mode (src.logic.cocktailsLogic)': 'setSearchMode'
    'load cocktails (src.logic.cocktailsLogic)': 'loadCocktails'
    'load cocktails success (src.logic.cocktailsLogic)': 'loadCocktailsSuccess'
    'load cocktails failure (src.logic.cocktailsLogic)': 'loadCocktailsFailure'
    'load ingredients (src.logic.cocktailsLogic)': 'loadIngredients'
    'load ingredients success (src.logic.cocktailsLogic)': 'loadIngredientsSuccess'
    'load ingredients failure (src.logic.cocktailsLogic)': 'loadIngredientsFailure'
  }
  actionTypes: {
    fetchCocktails: 'fetch cocktails (src.logic.cocktailsLogic)'
    fetchIngredients: 'fetch ingredients (src.logic.cocktailsLogic)'
    setSearchTerm: 'set search term (src.logic.cocktailsLogic)'
    addSelectedIngredient: 'add selected ingredient (src.logic.cocktailsLogic)'
    removeSelectedIngredient: 'remove selected ingredient (src.logic.cocktailsLogic)'
    setSearchMode: 'set search mode (src.logic.cocktailsLogic)'
    loadCocktails: 'load cocktails (src.logic.cocktailsLogic)'
    loadCocktailsSuccess: 'load cocktails success (src.logic.cocktailsLogic)'
    loadCocktailsFailure: 'load cocktails failure (src.logic.cocktailsLogic)'
    loadIngredients: 'load ingredients (src.logic.cocktailsLogic)'
    loadIngredientsSuccess: 'load ingredients success (src.logic.cocktailsLogic)'
    loadIngredientsFailure: 'load ingredients failure (src.logic.cocktailsLogic)'
  }
  actions: {
    fetchCocktails: () => void
    fetchIngredients: () => void
    setSearchTerm: (term: string) => void
    addSelectedIngredient: (ingredient: string) => void
    removeSelectedIngredient: (ingredient: string) => void
    setSearchMode: (mode: 'complete' | 'missing') => void
    loadCocktails: () => void
    loadCocktailsSuccess: (cocktails: Cocktail[], payload?: any) => void
    loadCocktailsFailure: (error: string, errorObject?: any) => void
    loadIngredients: () => void
    loadIngredientsSuccess: (ingredients: Ingredient[], payload?: any) => void
    loadIngredientsFailure: (error: string, errorObject?: any) => void
  }
  asyncActions: {
    fetchCocktails: () => Promise<any>
    fetchIngredients: () => Promise<any>
    setSearchTerm: (term: string) => Promise<any>
    addSelectedIngredient: (ingredient: string) => Promise<any>
    removeSelectedIngredient: (ingredient: string) => Promise<any>
    setSearchMode: (mode: 'complete' | 'missing') => Promise<any>
    loadCocktails: () => Promise<any>
    loadCocktailsSuccess: (cocktails: Cocktail[], payload?: any) => Promise<any>
    loadCocktailsFailure: (error: string, errorObject?: any) => Promise<any>
    loadIngredients: () => Promise<any>
    loadIngredientsSuccess: (ingredients: Ingredient[], payload?: any) => Promise<any>
    loadIngredientsFailure: (error: string, errorObject?: any) => Promise<any>
  }
  defaults: {
    cocktails: any
    cocktailsLoading: boolean
    ingredients: any
    ingredientsLoading: boolean
    selectedIngredients: Set<string>
    searchTerm: string
    searchMode: 'complete' | 'missing'
  }
  events: {}
  key: undefined
  listeners: {
    fetchCocktails: ((
      action: {
        type: 'fetch cocktails (src.logic.cocktailsLogic)'
        payload: {
          value: true
        }
      },
      previousState: any
    ) => void | Promise<void>)[]
    fetchIngredients: ((
      action: {
        type: 'fetch ingredients (src.logic.cocktailsLogic)'
        payload: {
          value: true
        }
      },
      previousState: any
    ) => void | Promise<void>)[]
  }
  path: ['src', 'logic', 'cocktailsLogic']
  pathString: 'src.logic.cocktailsLogic'
  props: Record<string, unknown>
  reducer: (
    state: any,
    action: any,
    fullState: any
  ) => {
    cocktails: any
    cocktailsLoading: boolean
    ingredients: any
    ingredientsLoading: boolean
    selectedIngredients: Set<string>
    searchTerm: string
    searchMode: 'complete' | 'missing'
  }
  reducers: {
    cocktails: (state: any, action: any, fullState: any) => any
    cocktailsLoading: (state: boolean, action: any, fullState: any) => boolean
    ingredients: (state: any, action: any, fullState: any) => any
    ingredientsLoading: (state: boolean, action: any, fullState: any) => boolean
    selectedIngredients: (state: Set<string>, action: any, fullState: any) => Set<string>
    searchTerm: (state: string, action: any, fullState: any) => string
    searchMode: (state: 'complete' | 'missing', action: any, fullState: any) => 'complete' | 'missing'
  }
  selector: (state: any) => {
    cocktails: any
    cocktailsLoading: boolean
    ingredients: any
    ingredientsLoading: boolean
    selectedIngredients: Set<string>
    searchTerm: string
    searchMode: 'complete' | 'missing'
  }
  selectors: {
    cocktails: (state: any, props?: any) => any
    cocktailsLoading: (state: any, props?: any) => boolean
    ingredients: (state: any, props?: any) => any
    ingredientsLoading: (state: any, props?: any) => boolean
    selectedIngredients: (state: any, props?: any) => Set<string>
    searchTerm: (state: any, props?: any) => string
    searchMode: (state: any, props?: any) => 'complete' | 'missing'
    sortedIngredientNames: (state: any, props?: any) => IngredientSearchItem[]
    filteredCocktails: (state: any, props?: any) => Cocktail[]
    missingIngredients: (state: any, props?: any) => Record<string, string[]>
  }
  sharedListeners: {}
  values: {
    cocktails: any
    cocktailsLoading: boolean
    ingredients: any
    ingredientsLoading: boolean
    selectedIngredients: Set<string>
    searchTerm: string
    searchMode: 'complete' | 'missing'
    sortedIngredientNames: IngredientSearchItem[]
    filteredCocktails: Cocktail[]
    missingIngredients: Record<string, string[]>
  }
  _isKea: true
  _isKeaWithKey: false
  __keaTypeGenInternalSelectorTypes: {
    sortedIngredientNames: (ingredients: any) => IngredientSearchItem[]
    filteredCocktails: (
      cocktails: any,
      selectedIngredients: Set<string>,
      searchMode: 'complete' | 'missing',
      ingredients: any
    ) => Cocktail[]
    missingIngredients: (cocktails: any, selectedIngredients: Set<string>, ingredients: any) => Record<string, string[]>
  }
}
